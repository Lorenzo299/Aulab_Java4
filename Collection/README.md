COLLECTION FRAMEWORK

STRUTTURA DATI E UN METODO SISTEMATICO PER ORG MEMORIZZARE E GESTIRE DATI IN UNA MEMORIA, FACILITANDO L ACCESSO E MANIPOLAZIONE

ARRAY E UNA STRUT DATI BASATA SU DATI DI STESSO TIPO CON UN ORDINE SPECIFICO INDICIZZATO

COLLECTION SONO STRUTTURE DATI CHE PERMETTONO LA GESTIONE DI UN INSIME DI ELEMENTI

.ADD
.ADDALL AGGIUNGE UNA COLLEZIONE INTERA AD UN ALTRA
.CLEAR SVUOTA
.CONTAINS BOOLEAN
.CONTAINSALL //
ISEMPTY ///
.REMOVE 
.REMOVEALL
.SIZE
.TOARRAY

IN JAVA PERCIO UNA COLLECTION E UNA INTERFACCIA DEL JAVA COLLECTION FRAMEWORK JCF

COLLECTION E UN INSIME DI OGGETTI, TIPI DI COLLECTION 

LIST: INTERFACCIA DI JCF DOVE OGNI ELEMENTO HA UN INDICE, ESTENDE L INTERFACCIA COLLECTION, E HA 2 IMPLEMNTAZIONI PER ESSERE ESEGUITA: ARRAYLIST E LINKEDLIST

ARRAYLIST : E UNA CLASSE CHE IMPLEMENTA INTERFACE LIST CHE HA UNA STRUTTURA DATI BASATA SU UN ARRAY DINAMICO. GLI OGGETTI VENGONO SALVATI IN LOCAZIONI DI MEMORIA CONTIGUE NEL SENSO CHE CAMBIANO IN BASE HA QUANTI DATI HANNO AL LORO INTERNO, SE LA LOCAZIONE E PIENA TUTTI GLI OGGENTI VENGONO COPIATI IN UNA NUOVA COLLEZIONE

IMPORT JAVA.UTIL.ARRAYLIST
IMPORT JAVA.UTIL.LIST
LIST<PERSON> PERSONA = NEW ARRAYLIST<PERSON>();
ABBIAMO USATO LIST COME TIPO DI OGGETTI PER BEST PRACTICE PERCHE FACILITA IL CAMBIO DI IMPLEMENTAZIONE E LA MANUTENIBILITA

persona.ADD PER ISTANZIARE OGGETTI PERSON CHE VANNO ALL INTERNO DELL ARRAYLIST

SE VOGLIO ISTANZIARE GLI OGGETTI CONTESTUALMENTE ALLA CREAZIONE DELL ARRAYLIST FARO
List<Car> garage = List.of(
                (new Car("Fiat 500", "Bianca", 12000)),
                (new Car("Toyota Yaris", "Nera", 20000)));
utilizzando percio il metodo .of richiamato sulla List direttamente.

CON IL FOREACH STAMPO L ARRAYLIST PERSON CON I METODI GET'NOMEVARIABILE' NEL CASO SIANO GETTERS all interno del foreach perche e un metodo dell oggetto, non dell arraylist totale.

ITERABILE E UN INTERFACCCIA CHE IMPLEMENTANO TUTTE LE COLLECTION CHE PERMETTE, COME IL FOREACH, DI ITERARE TUTTI GLI ELEMNTI;
SI CREA UN OGGETTO ITERATOR DIRETTAMENTE DAL TIPO DELLA LIST GIA CREATA E RICHIAMANDO IL METODO ITERATO() DALLA LISTA STESSA.
L OGGETTO ITERATOR CONTIENE 2 METODI:
HASNEXT() CHE RITORNA TRUE FINCHE NON SI ARRIVA ALL ULTIMO ELEMENTO, OSSIA FINCHE CE NE UNO DOPO CONTINUA IL CICLO
NEXT() RITORNO L ELEMENTO SUCCESSIVO DELLA COLLECTION

ITERATOR<PERSON> IT = PERSONA.ITERATOR();
WHILE(IT.HASNEXT()){
    PERSON P = IT.NEXT(); IT VIENE ITERATO FINCHE HA UNO NUOVO E LO COLLEGO A P PER OTTENERLO DOPO NEL SOP
    SYSTEM.OUT.PRINTLN(P.GETNOME()+.....)
}

QUESTO E ESATTAMENTE IL MECCANISMO DEL FOREACH

PERSONA.SET(INDICEPOSIZIONE, NEW PERSON (....) );
SOSTITUISCE UN OGGETTO NELL INDICE INDICATO CON UN NUOVO APPENA CREATO

PERSONA.REMOVE(INDICE); LO RIMUOVE

PERSONA.CLEAR(); SVUOTA LA LIST.


LINKEDLIST: CLASSE CHE IMPLEMENTE L'INTERFACCIA LIST, HA LA PARTICOLARITA CHE OGNI DATO E DOPPIAMENTE COLLEGATO COL PRECENDETE E IL SUCCESSIVO (SINGLE LINK SOLO CON IL SUCCESSIVO), TRAMITE DEI PUNTATORI.
I DATI A DIFFERENZA DI ARRAYLIST NON SONO SALVATI IN MEMORIE CONTIGUE, MA IN LOCAZIONI SPARSE, IN QUANTO L'ORDINE E COMUNQUE GARANTITO DAL LINKAGGIO COL PRECEDENTE E SUCCESSIVO.
IL PRIMO DATO AVRA VALORE UN VALORE NULL COME DATO PREC, L ULTIMO AVRA VALORE NULL COME DATO SUCCESSIVO (HEAD E TAIL).
.ADDFIRST .ADDLAST .REMOVEFIRST .RMOVELAST .GETFIRST .GETLAST

LIST<PERSON> PERSONA = NEW LINKEDLIST<PERSON>();
LIST<PERSON> PERSONA = NEW LINKEDLIST<PERSON>(LIST.OF(NEW PERSON (ATTRIBUTI))); QUESTI ISTANZIO DIRETTAMENTE GLI OGGETTI DELLA LISTA

IL FOREACH E IDENTICO

.ADD(INDICE, NEW PERSON) AGGIUNGE IL DATO A QUELL INDICE E SPOSTA QUELLI SUCCESSIVI

,ADDALL(INDICE, LIST.OF(NEW PERSON, NEW PERSON,...,))

.GET(INDICE) CATTURA QUEL DATO




SET: INTERFACCIA STRUTTURA DATI UTILIZZATA PER CREARE COLLEZIONI CHE NONN AMMETTONO DUPLICATI, TEORIA INSIEMISTICA
LIST.OF E SET.OF CREANO UNA COLLEZIONE IMMUTABILE

SET<POINTER3D> PUNTI = SET.OF(NEW POINTER3D(....), NEW POINTER3D(....) )
LA PROCEDURA E UGUALE ALLE LIST

SET CONTROLLA SE SONO DUPLICATI CO I MEDOTI EQUALS E HASHCODE, EQUALS CONTROLLA LA CELLA DI MEMORIA A DOVE PUNTA, HASH AL LORO NUMERO HASH: SE RESTITUISCONO TRUE ALLORA SONO DUPLICATI

OVERRIDE EQUALS(OBJECT OBJ){
    IF(THIS==OBJ) RETURN TRUE;
    IF(OBJ ==NULL || GETCLASS() != OBJ.GETCLASS()) RETURN FALSE;

    POINTER3D OTHER = (POINTER3D) OBJ;//CASTING 
    RETURN X ==OTHER.X && Y=OTHER.Y  && W==OTHER.W;
}

OVERRIDE HASHCODE(){
    RETURN OBJECTS.HASH(X,Y,W);
}

HASHSET CLASSE CHE IMPLEMENTE SET UTILIZZANDP UN HASH TABLE PER MEMORIZZARE I DATI E GESTIRLI, NON PERMETTE DUPLICATI E ORDINAMENTO E CASUALE, HA SOLO UN NULL AL MAX ED HA PRESTAZIONI ELEVETE PERCHE INSERIMENTO RICERCA E RIMOZIONE DI DATI E VELOCE
.ADD Ã¨PER AGGIUNGERE
E INDICATA PER UN GRAN NUMERO DI DATI E FACILATI LA LORO RICERCA
SET<POINTER> POINTS = NEW HASHSET<>(SET.OF(NEW POINTER,...,..,))

TREESET CLASSE CHE IMPLEMENTA SET SEGUENDO REGOLE DI STRUTTURA CHIAMATA ALBERO:
ORDINAMENTO AUTOMATICO, O PERSONALIZZATO ATTRAVERSO UN COMPARATORE
NESSUN DUPLICATO, 
METODI VELOCI .FIRST .LAST .HIGHER .LOWER .FLOOR .CEILING
OPERAZIONE INSERIMENTO E RIMOZIONE VELOCI
OTTIMIZZATO PER LA RICERCA MA NON CONSIGLIATO PER UN VOLUME AMPIO DI DATI.

ORDINAMENTO NATURALE : INT VENGONO MESSI IN ORDINE CRESC, STRING IN ORDINE ALFABETICO

COMPARATOR: INTERFACCIA CHE SERVE A DEFINIRE UN CRITERIO PER ORDINARE OGGETTI, METODO COMPARE INT COMPARE(T o1, T o2); CHE RESTITUISCE UN NEGATIVO SE o1 < o2, ZERO SE o1==o2, POSITIVO SE o1> o2;
RECORD: CLASSE CONCISA PER CONTENERE DATI CHE QUANDO VEINE DICHIARATA GENERE AUTOMATICAMENTE METODI COME EQUALS HASCODE TOSTRING E GETTER E SETTER
PUBLIC RECORD POINT3D(INT X, INT Y){

}
DA RIVEDERE MINUTO 50 CIRCA FINO 59



MAP INTERFACCIA CHE RAPPRESENTA UNA UNA RACCOLTA DI COPPIE CHIAVE VALORE, CON CHIAVI UNIVOCHE, PER ACCEDERVI FACILMENTE.
E AFFIDABILE, EFFICIENTE E FLESSIBILE.

MAP NON IMPLEMENTA COLLECTION PERCIO POSSIEDE DIVERSI METODI:
.PUT(KEY, VALUE) AGGIUNGE
.GET(OBJECT KEY) RESTITUISCE
.CONTAINSKEY(OBJECT CHIAVE) RITORNA TRUE SE LA MAP CONTIENE LA KEY
.CLEAR() RIMUOVE TUTTI
.KEYSET()RITORNA UN SET CON TUTTE LE CHIAVI
.VALUE() RITORNA UNA COLLECTION CON I SOLO VALORI DELLA MAP

HASHMAP E L IMPLEMENTAZIONE PIU UTILIZZATA
LE MAP SONO UTILIZZATE PERCHE GRAZIE ALLA KEY CON CUI VENGONO MAPPATI GLI ELEMENTI QUESTI SONO FACILMENTE E VELOCEMENTE RICERCATI
QUESTA VELOCITA E DOVUTO AI BUCKETS, SONO 16 CESTI DOVE VENGONO SALVATI GLI ELEMENTI E LA LORO POSIZIONE AVVIENE GRAZIE AD UN CALCOLO DI UN HASHCODE LANCIATO SULLA CHIAVE E L HASHCODE VIENE INSERITO NEL BUCKET( I BUCKET SONO DELLE LINKEDLIST)

DICHIARAZIONE E INIZIALIZZAZIONE DELLA MAPPA
MAP<STRING, PERSON> PERSONAMAP = NEW HASHMAP<>();
PERSONAMAP.PUT(CHIAVE, NEW PERSON(ATTRIBUTI)) 

E UNA MAP DOVE LE CHIAVI SONO STRINGHE E I VALORI DEGLI OGGETTI DI PERSON, DI TIPO MAP COME HASHMAP

DOBBIAMO ASSEGNARE UN OGGETTO AI DATI DELL HASHMAP PER POTERLO RICHIAMARE CON UN METODO DELLE MAP

PERSON MARIOROSSI= PERSONAMAP.GET(CHIAVE)
SOP(MARIOROSSI + MARIOROSSI.NAME+ MARIOROSSI.SURNAME)
CI STAMPERERA= RIFERIMENTO, NOME, COGNOME

BOOLEAN HASMARIOROSSI = PERSONMAP.CONTAINSKEY(CHIAVE)
SOP(HASMARIOROSSI) CI RESTITUIRA TRUE O FALSE IN BASE AL FATTO CHE LA CHIAVE PASSATA SIA UN DATO CONTENUTO IN PERSONMAP CHE ABBIAMO UGUAGLIATO A HASMARIOROSSI

PERSONAMAP.REMOVE(CHIAVE) RIMUOVE DALL HASHMAP PERSONAMAO IL DATO CON LA CHIAVE

FOREACH
FOR(MAP.ENTRY<STRING,PERSON> ENTRY: PERSONAMAP.ENTRYSET()){
   SOP(ENTRY.GETKEY + ENTRY.GETVALUE) 
}
CI TORNERANNO TUTTI GLI ELEMENTI DELLA MAP ( CHE SONO DEFINITI NEL CICLO CON PERSONAMAP.ENTRYSET()) STAMPANDO LA CHIAVE E IL RIFERIMENTO(.GETKEY E .GETVALUE), CHE SONO GESTITI NEL CICLO COME ENTRY CHE SARA UN MAP.ENTRY<STRING,PERSON>


TRASMORMO IL CODICE FISCALE CHE ERA LA NOSTRA CHIAVE, DA UNA STRINGA AD UN OGGETTO RUBRICAKEY 
CREO LA CLASSE RUBRICAKEY CON ATTRIBUTO STRING CF

DICHIARAZIONE E INIZIALIZZAZIONE DELLA NUOVA MAPPA
MAP<RUBRICAKEY, PERSON> PERSONAMAP = NEW HASHMAP<>();
PERSONAMAP.PUT(NEW RUBRICAKEY(ATTRIBUTO), NEW PERSON(ATTRIBUTI)) 

IL FOREACH SARA PERCIO
FOR(MAP.ENTRY<RUBRICAKEY,PERSON> ENTRY : PERSONAMAP.ENTRYSET()){
    SOP(ENTRY.GETKEY + ENTRY GET VALUE)
}

A QUESTO PUNTO PERO SE NOI INSERIAMO NELL HASHMAP DUE VALORI UGUALI, IL CODICE NON DA ERRORE PERCHE I CONTROLLI DELL EQUALS E HASHCODE FARANNO RIFERIMENTO ALLE CELLE DI MEMORIA E NON AI VALORI STESSI, SARA NECESSARIO OVERRIDE I DUE METODI IN RUBRICAKEY

EQUALS DOVREMMO
CONTROLLARE SE UNO E NULL O APPARTENGONO A CLASSI DIVERSE RETURN FALSE
SE THIS==OBJ   RETURN TRUE
CASTARE I VALORI CREANDO UN ISTANZA PER CONFRONTARE I VALORI
RETURN TRUE

PUBLIC BOOLEAN EQUALS(OBJECT OBJ){
    IF(THIS==OBJ) RETURN TRUE;
    IF(OBJ==NULL || OBJ.GETCLASS() != THIS.GETCLASS()) RETURN FALSE;
    RUBRICAKEY R = (RUBRICAKEY)OBJ;
    RETURN OBJECTS.EQUALS(CF, R.CF)// EQUALS RESTITUISCE TRUE SE I VALORI SONO UGUALI
}

PUBLIC INT HASHCODE(){
    RETURN OBJECTS.HASH(CF)
}

RESTUISCE LO STESSO INT SE DUE KEY HANNO LO STESSO HASHCODE


TREEMAP COLLEZIONE COPPIE CHIAVE VALORE COME UN TREESET

COMPARATOR

CLASSE RUBRICAKEYCOMPARATOR

PUBLIC CLASS RUBRICAKEYCOMPARATOR IMPLEMENTS COMPARATOR <RUBRICAKEY>{

    PUBLIC INT COMPARE(RUBRICAKEY K1, RUBRICAKEY K2){
        RETURN K1.CF.COMPARETO(K2.CF)
    }

}

IN APP

SORTEDMAP<RUBRICAKEY,PERSON> PERSONAMAP = NEW TREEMAP<RUBRICAKEY,PERSON>(NEW RUBRICAKEYCAMPARATOR());

FOR(RUBRICAKEY KEY : PERSONAMAP.KEYSET()){
    SOP(PERSONAMAP.GET(KEY).NAME + PERSONAMAP.GET(KEY).CF)
}




GENERICS
SONO DEI DATI ASTRATTI, SENZA TIPO. CLASSI INTERFACCE E METODI PARAMETRIZZATI SENZA TIPO DEFINITO MA USANDO CONSONTANTI ES K T ECC QUESTO PERMETTE DI CREARE CODICE RIUTILIZZABILE SENZA NECESSITA DI CONVERSIONI ESPLICITE DI DATO COME IL CASTING: IL TIPO DI DATO VERRA SPECIFICATO NELL ISTANZA

PUBLIC CALSS GENERICCLASS<T>{
    PRIVATE T DATA;
    PERCIO COSTRUTTORI E GETTER E SETTER AVRANNO T AL POSTO DI STRING AD ESEMPIO
}

IN APP

GENERICCLASS<STRING> ESSTRING = NEW GENERICCLASS<STRING>("STRINGA TIPO");
SOP(GENER.GETDATA())
GENERICCLASS<INT> ESINT= NEW GENERICCLASS<INT>(5);
SOP(GENER.GETDATA())

QUANDO ISTANZIO DEVO SPECIALIZZARE IL TIPO

POSSO GENERALIZZARE ANCJHE I METODI ANCHE IN UNA CLASSE NON GENERICA, PERCHE PER ES MI SERVE CHE UN METODO PASSI UN PARAMETRO DI CUI ANCORA NON SO IL TIPO
PUBLIC CLASS GENCLA{

PUBLIC <T> VOID PRINT(<T> DATA){
    SOP(DATA);
}
}

IN APP

GENCLA GEN = NEW GENCLA();
GEN.<STRING>PRINT("UNA STRING");
GEN.<INT>PRINT(55);


SE VOGLIAMO NON SPECIFICARE IL TIPO DEL RITORNO
PUBLIC CLASS GENCLA{

PUBLIC <T> T GENRETURN(<T> DATA){
   RETURN DATA;
   }
}


CLASSE CON PIU GENERICS

PUBLIC CLASS GENERIC<T1, T2>{
    T1 PARAMETRO1;
    T2 PARAMETRO2;
}

IN APP

GENERIC<STRING, INT> BOO = NEW GENERIC<STRING,INT>("STRINGA",44);




